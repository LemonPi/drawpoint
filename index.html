<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>drawpoint</title>
    <script src="node_modules/context-2d-tracked/dist/Context2DTracked.min.js"></script>
    <script src="dist/drawpoint.js"></script>
</head>
<body>
<canvas id="cv" width="600" height="600" style="border:solid black 2px"></canvas>
<div>
    <button id="clear">clear</button>
    <button id="line">line</button>
    <button id="quadratic">quadratic curve</button>
    <button id="bezier">bezier curve</button>
</div>

<div>
    <input type="checkbox" id="trace" name="trace" value="trace" checked>
    <label for="trace">Show control points</label>
</div>
</div>
<div>
    <p id="explanation">Click on the canvas to set points down. Different modes expect different number of points
        to draw a curve.</p>
</div>
<script>
    "use strict";
    console.log(drawpoint);
    var cv = document.getElementById("cv");
    // var explanation = document.getElementById("explanation");

    // can use just as a global variable in the browser
    var ctx = new Context2DTracked(cv.getContext("2d"));

    // different modes expect different number of drawpoints; by default we enter line mode
    var expectedPoints = 0;
    var points = [];

    function clearCanvas() {
        var canvasDimensions = ctx.transformPoint(cv.width, cv.height);
        ctx.clearRect(0, 0, canvasDimensions.x, canvasDimensions.y);
        points = [];
    }

    // preprocess points into the format to draw a curve
    var processPoints = null;
    function lineMode() {
        expectedPoints = 2;
        processPoints = function () {
            // do nothing
        };
    }

    function quadraticMode() {
        expectedPoints = 3;

        processPoints = function (points) {
            points[2].cp1 = points[1];
            // swap out
            points[1] = points[2];
            points.length = 2;

        };
    }

    function bezierMode() {
        expectedPoints = 4;

        var cp1, cp2;
        processPoints = function (points) {
            points[3].cp1 = points[1];
            points[3].cp2 = points[2];
            points[1] = points[3];
            points.length = 2;
        }
    }


    cv.addEventListener("click", function (e) {
        e.preventDefault();
        var x;
        var y;
        if (e.pageX || e.pageY) {
            x = e.pageX;
            y = e.pageY;
        } else {
            x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }
        x -= cv.offsetLeft;
        y -= cv.offsetTop;

        var pt = drawpoint.point(x, y);

        ctx.beginPath();
        drawpoint.drawPoints(ctx, ...drawpoint.drawCircle(pt, 1));
        ctx.stroke();
        ctx.fill();

        points.push(pt);

        if (points.length === expectedPoints) {
            processPoints(points);
            ctx.beginPath();
            drawpoint.drawPoints(ctx, ...points);
            points[0] = points[points.length - 1];
            points.length = 1;
            ctx.stroke();
        }

        return false;
    });

    ctx.lineWidth = 2;
    // default to simple line mode
    lineMode();

    document.getElementById("clear").addEventListener("click", clearCanvas);
    document.getElementById("line").addEventListener("click", lineMode);
    document.getElementById("quadratic").addEventListener("click", quadraticMode);
    document.getElementById("bezier").addEventListener("click", bezierMode);
    var traceToggle = document.getElementById("trace");
    function traceControl() {
        console.log(traceToggle.checked);
        ctx.showcontrol = traceToggle.checked;
    }
    traceToggle.onchange = traceControl;
    traceControl();
</script>
</body>
</html>