{"version":3,"file":"drawpoint.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 28596f7150e5a7313d43","webpack:///src/point.js","webpack:///src/curve.js","webpack:///src/numeric.js","webpack:///src/draw.js","webpack:///src/util.js","webpack:///src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"drawpoint\"] = factory();\n\telse\n\t\troot[\"drawpoint\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 28596f7150e5a7313d43","\"use strict\";\r\n\r\nexport function point(x, y) {\r\n    return {\r\n        x,\r\n        y\r\n    };\r\n}\r\n\r\n/**\r\n * Make a new point where each dimension is the result of applying a function to\r\n * the corresponding dimension of a list of control points.\r\n * @param func\r\n * @param cps\r\n * @returns {{x, y}|*}\r\n */\r\nexport function makePoint(func, ...cps) {\r\n    return point(\r\n        func(...cps.map(cp => cp.x)),\r\n        func(...cps.map(cp => cp.y)));\r\n}\r\n\r\nexport const origin = Object.freeze(point(0, 0));\r\n\r\n/**\r\n * Insert this special point in the list of points given to drawPoints to\r\n * move to the next point instead of drawing to the next point\r\n * @readonly\r\n * @type {Object}\r\n */\r\nexport const breakPoint = Object.freeze({\r\n    break: true\r\n});\r\n\r\n/**\r\n * Signals for a fill path to not try to complete it by drawing a curve from end\r\n * point to first point as the fill has already done its job\r\n * move to the next point instead of drawing to the next point\r\n * @readonly\r\n * @type {Object}\r\n */\r\nexport const endPoint = Object.freeze({\r\n    end: true\r\n});\r\n\r\n/**\r\n * Treat points as vectors and add them, optionally after scaling p2\r\n * @param p1\r\n * @param p2\r\n * @param scaleBy\r\n * @returns {{x: *, y: *}}\r\n */\r\nexport function add(p1, p2, scaleBy = 1) {\r\n    return makePoint((pp1, pp2) => {\r\n        return pp1 + pp2 * scaleBy;\r\n    }, p1, p2);\r\n}\r\n\r\n/**\r\n * Get the difference of 2 draw points p2 - p1; conceptually a vector pointing p1 -> p2\r\n * @param {{x:number, y:number}} p1 First point\r\n * @param {{x:number, y:number}} p2 Second point\r\n * @returns {{x: number, y: number}}\r\n */\r\nexport function diff(p1, p2) {\r\n    return makePoint((pp1, pp2) => {\r\n        return pp2 - pp1;\r\n    }, p1, p2);\r\n}\r\n\r\n/**\r\n * Get the magnitude of a vector\r\n * @param vec\r\n * @returns {number} Euclidean (L^2) norm of vec\r\n */\r\nexport function norm(vec) {\r\n    return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\r\n}\r\n\r\n/**\r\n * Get the angle of a vector in radians\r\n * @param vec\r\n * @returns {number} Angle in radians\r\n */\r\nexport function angle(vec) {\r\n    return Math.atan2(vec.y, vec.x);\r\n}\r\n\r\n/**\r\n * Get a point after scaling it relative to a reference point.\r\n * Grows the vector referencePt -> pt by scaleBy.\r\n * @param pt\r\n * @param scaleBy\r\n * @param referencePt The point from which to scale\r\n * @returns {{x: *, y: *}}\r\n */\r\nexport function scale(pt, scaleBy, referencePt = origin) {\r\n    return add(referencePt, diff(referencePt, pt), scaleBy);\r\n}\r\n\r\n\r\n/**\r\n * Relative to 0,0, get the direction a draw point/vector is pointing at\r\n * @param vec\r\n * @returns {{x: number, y: number}}\r\n */\r\nexport function getUnitVector(vec) {\r\n    const magnitude = norm(vec);\r\n    return makePoint(v => v / magnitude, vec);\r\n}\r\n\r\n/**\r\n * Get counterclockwise perpendicular unit vector\r\n * @param vec Point that doubles as a vector from (0,0) to the point\r\n * @returns {{x: number, y: number}}\r\n */\r\nexport function getPerpendicularVector(vec) {\r\n    // rotate counterclockwise by 90 degrees\r\n    return getUnitVector(point(-vec.y, vec.x));\r\n}\r\n\r\n/**\r\n * Remove any extra information from a point down to just x,y\r\n */\r\nexport function extractPoint(pt) {\r\n    return point(pt.x, pt.y);\r\n}\r\n\r\n/**\r\n * Remove any extra information from a point and reflect across y axis\r\n */\r\nexport function reflect(pt, m = Infinity, b = 0) {\r\n    if (!pt) {\r\n        return pt;\r\n    }\r\n    let c, cm;\r\n\r\n    // vertical linear\r\n    if (m === Infinity) {\r\n        c = 0;\r\n        cm = 0;\r\n        // has no single y-intercept\r\n        b = pt.y;\r\n    } else {\r\n        c = (pt.x + (pt.y - b) * m) / (1 + m * m);\r\n        cm = c * m;\r\n    }\r\n\r\n    return point(\r\n        2 * c - pt.x,\r\n        2 * cm - pt.y + 2 * b\r\n    );\r\n}\r\n\r\n/**\r\n * Shift a draw point and its control points\r\n * @param {object} pt\r\n * @param {number} dx\r\n * @param {number} dy\r\n * @returns {object}\r\n */\r\nexport function adjust(pt, dx, dy) {\r\n    if (!pt) {\r\n        return pt;\r\n    }\r\n    // return a point with x and y adjusted by dx and dy respectively\r\n    const movedPoint = point(pt.x + dx, pt.y + dy);\r\n    if (pt.cp1) {\r\n        movedPoint.cp1 = point(pt.cp1.x + dx, pt.cp1.y + dy);\r\n    }\r\n    if (pt.cp2) {\r\n        movedPoint.cp2 = point(pt.cp2.x + dx, pt.cp2.y + dy);\r\n    }\r\n    return movedPoint;\r\n}\r\n\r\n/**\r\n * Shift a sequence of draw points\r\n * @param dx\r\n * @param dy\r\n * @param points\r\n * @returns {Array}\r\n */\r\nexport function adjustPoints(dx, dy, ...points) {\r\n    const shiftedPoints = [];\r\n    points.forEach((pt) => {\r\n        shiftedPoints.push(adjust(pt, dx, dy));\r\n    });\r\n    return shiftedPoints;\r\n}\r\n\r\n/**\r\n * Explode or shrink points around a center point\r\n * @param center The point other points are scaled relative to\r\n * @param {number} scaleBy Multiplier for the distance between each point and center\r\n * @param points Points to scale relative to center\r\n */\r\nexport function scalePoints(center, scaleBy, ...points) {\r\n    points.forEach((pt) => {\r\n        if (!pt || pt.hasOwnProperty(\"x\") === false) {\r\n            return;\r\n        }\r\n        const {x, y} = scale(pt, scaleBy, center);\r\n        pt.x = x;\r\n        pt.y = y;\r\n        if (pt.cp1) {\r\n            pt.cp1 = scale(pt.cp1, scaleBy, center);\r\n        }\r\n        if (pt.cp2) {\r\n            pt.cp2 = scale(pt.cp2, scaleBy, center);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Rotate a set of points about a pivot in place\r\n * @param {object} pivot The point to rotate about\r\n * @param {number} rad Radians counterclockwise to rotate points\r\n * @param points List of points to rotate about pivot\r\n */\r\nexport function rotatePoints(pivot, rad, ...points) {\r\n    let cos = Math.cos(rad), sin = Math.sin(rad);\r\n    points.forEach((pt) => {\r\n        if (!pt || pt.hasOwnProperty(\"x\") === false) {\r\n            return;\r\n        }\r\n        rotateDiff(pivot, pt, sin, cos);\r\n        if (pt.cp1) {\r\n            rotateDiff(pivot, pt.cp1, sin, cos);\r\n        }\r\n        if (pt.cp2) {\r\n            rotateDiff(pivot, pt.cp2, sin, cos);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Helper for rotate points to be used with cached sin and cos\r\n * @param pivot Point around which to rotate\r\n * @param pt Point to be rotated\r\n * @param sin Cached sin(rad) to rotate by\r\n * @param cos Cached cos(rad) to rotate by\r\n */\r\nfunction rotateDiff(pivot, pt, sin, cos) {\r\n    const pointDiff = diff(pivot, pt);\r\n    const dx = pointDiff.x * cos - pointDiff.y * sin;\r\n    const dy = pointDiff.x * sin + pointDiff.y * cos;\r\n    pt.x = pivot.x + dx;\r\n    pt.y = pivot.y + dy;\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/point.js","/**\r\n * Created by johnson on 11.05.17.\r\n */\r\n\r\nimport {add, makePoint, extractPoint, diff, getPerpendicularVector} from \"./point\";\r\nimport {roundToDec} from \"./numeric\";\r\n\r\nexport function applyToCurve(p1, p2, {linear, quadratic, cubic}) {\r\n    const ep1 = extractPoint(p1);\r\n    const ep2 = extractPoint(p2);\r\n    if (p2.cp1 && p2.cp2) {\r\n        return cubic(ep1, p2.cp1, p2.cp2, ep2);\r\n    }\r\n    const cp = p2.cp1 || p2.cp2;\r\n    if (cp) {\r\n        return quadratic(ep1, cp, ep2);\r\n    } else {\r\n        return linear(ep1, ep2);\r\n    }\r\n}\r\n\r\n/**\r\n * Get a point at t (out of [0,1]) along the [p1, p2] curve\r\n * @param t\r\n * @param p1\r\n * @param p2\r\n * @returns {*}\r\n */\r\nexport function getPointOnCurve(t, p1, p2) {\r\n    return applyToCurve(p1, p2, {\r\n        linear: (...cps) => getPointOnLine(t, ...cps),\r\n        quadratic(...cps) {\r\n            return makePoint(getQuadraticValue.bind(null, t), ...cps);\r\n        },\r\n        cubic(...cps) {\r\n            return makePoint(getCubicValue.bind(null, t), ...cps);\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Shorthand for getting point on a line connecting p1 -> p2\r\n * Useful for force treatment of p2 as a linear end point even if it has control points\r\n * @param t\r\n * @param p1\r\n * @param p2\r\n * @returns {*}\r\n */\r\nexport function getPointOnLine(t, p1, p2) {\r\n    return makePoint(getLinearValue.bind(null, t), p1, p2);\r\n}\r\n\r\nfunction getLinearValue(t, p1, p2) {\r\n    // (1 - t) * p1 + t * p2\r\n    return t * (p2 - p1) + p1;\r\n}\r\n\r\nfunction getQuadraticValue(t, p1, cp, p2) {\r\n    // (1 - t)^2 * p1 + 2(1 - t)t * cp + t^2 * p2\r\n    // gather coefficients of t^2, t, and 1\r\n    return (p1 + p2 - 2 * cp) * t * t + 2 * (cp - p1) * t + p1;\r\n}\r\n\r\nfunction getCubicValue(t, p1, cp1, cp2, p2) {\r\n    // (1 - t)^3 * p1 + 3(1 - t)^2 * t * cp1 + 3(1 - t)t^2 * cp2 + t^3 * p2\r\n    // leave in unexpanded form\r\n    return p1 * (1 - t) * (1 - t) * (1 - t) + 3 * cp1 * (1 - t) * (1 - t) * t +\r\n           3 * cp2 * (1 - t) * t * t + p2 * t * t * t;\r\n}\r\n\r\nfunction splitBezier(t, p1, cp1, cp2, p2) {\r\n    // split a cubic cubic based on De Casteljau, t is between [0,1]\r\n    // just a series of linear interpolations\r\n    const E = getPointOnLine(t, p1, cp1);\r\n    const F = getPointOnLine(t, cp1, cp2);\r\n    const G = getPointOnLine(t, cp2, p2);\r\n    const H = getPointOnLine(t, E, F);\r\n    const J = getPointOnLine(t, F, G);\r\n    const K = getPointOnLine(t, H, J);\r\n\r\n    const left = {\r\n        p1,\r\n        p2: K\r\n    };\r\n    left.p2.cp1 = E;\r\n    left.p2.cp2 = H;\r\n\r\n    const right = {\r\n        p1: extractPoint(K),\r\n        p2\r\n    };\r\n    right.p2.cp1 = J;\r\n    right.p2.cp2 = G;\r\n\r\n    return {\r\n        left,\r\n        right\r\n    };\r\n}\r\n\r\nfunction splitQuadratic(t, p1, cp, p2) {\r\n    // split a quadratic cubic based on De Casteljau, t is between [0,1]\r\n    const D = getPointOnLine(t, p1, cp);\r\n    const E = getPointOnLine(t, cp, p2);\r\n    const F = getPointOnLine(t, D, E);\r\n\r\n    const left = {\r\n        p1,\r\n        p2: F\r\n    };\r\n    left.p2.cp1 = D;\r\n    const right = {\r\n        p1: extractPoint(F),\r\n        p2\r\n    };\r\n    right.p2.cp1 = E;\r\n\r\n    return {\r\n        left,\r\n        right\r\n    };\r\n}\r\n\r\nfunction splitLinear(t, p1, p2) {\r\n    // split a linear linear\r\n    const C = getPointOnLine(t, p1, p2);\r\n    return {\r\n        left : {\r\n            p1,\r\n            p2: C\r\n        },\r\n        right: {\r\n            p1: C,\r\n            p2\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Split the curve between two drawpoints and return all the resulting drawpoints\r\n * @memberof module:da\r\n * @param {number} t \"time\" along the curve to split at. Since all curves are parameterized\r\n * curves, t is their parameter. Can be thought of as traversing along the curve, where 0 is\r\n * at the start point and 1 is at the end point. This value can go beyond [0,1].\r\n * @param {object} p1 Starting drawpoint\r\n * @param {object} p2 Ending drawpoint and also where we look at the control points\r\n * @returns {{left, right}} Object having a left and right property, each with their own\r\n * p1 (start point), p2 (end point), and optionally cp1 and cp2 depending on what kind of\r\n * curve was split. Note that sp.left.p2 === sp.right.p1 always in value.\r\n */\r\nexport function splitCurve(t, p1, p2) {\r\n    // split either a quadratic or cubic curve depending on number of control points on\r\n    // the end point\r\n    return applyToCurve(p1, p2, {\r\n        linear   : splitLinear.bind(null, t),\r\n        quadratic: splitQuadratic.bind(null, t),\r\n        cubic    : splitBezier.bind(null, t),\r\n    });\r\n}\r\n\r\nfunction interpolateLinear(p1, p2, p) {\r\n    // infinite number of options, can't calculate\r\n    if (p2 === p1) {\r\n        return [];\r\n    }\r\n    // t\r\n    return [(p - p1) / (p2 - p1)];\r\n}\r\n\r\nfunction solveQuadraticEquation(a, b, c) {\r\n\r\n    const discriminant = b * b - 4 * a * c;\r\n\r\n    if (discriminant < 0) {\r\n        return [];\r\n\r\n    } else {\r\n        return [\r\n            (-b + Math.sqrt(discriminant)) / (2 * a),\r\n            (-b - Math.sqrt(discriminant)) / (2 * a)\r\n        ];\r\n    }\r\n}\r\n\r\n\r\nfunction interpolateQuadratic(p1, cp1, p2, p) {\r\n    const a = (p1 - 2 * cp1 + p2);\r\n    const b = 2 * (cp1 - p1);\r\n    const c = p1 - p;\r\n\r\n    // 2 possible values for t\r\n    return solveQuadraticEquation(a, b, c);\r\n}\r\n\r\nfunction cubeRoot(v) {\r\n    if (v < 0) {\r\n        return -Math.pow(-v, 1 / 3);\r\n    } else {\r\n        return Math.pow(v, 1 / 3);\r\n    }\r\n}\r\n\r\n/**\r\n * Solve a cubic equation of the form x^3 + a * x^2 + b * x + c = 0 for x\r\n * Uses Cardano's equation\r\n * See https://trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\r\n * @param a\r\n * @param b\r\n * @param c\r\n * @returns {*}\r\n */\r\nfunction solveCubicEquation(a, b, c) {\r\n\r\n    const a3 = a / 3;\r\n    // reduce to t^3 + p * t + q = 0 form\r\n    // always reducible by substituting x = t - a / 3\r\n    const p = (3 * b - a * a) / 3;\r\n    const p3 = p / 3;\r\n    const q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;\r\n    const q2 = q / 2;\r\n\r\n    // further transformation into (u - v)^3 + 3uv(u - v) = u^3 - v^3\r\n    // with substitutions p = 3uv, -q = u^3 - v^3, t = u - v\r\n    // v = p/(3u) substituted into\r\n    // u^3 - v^3 = -q gives\r\n    // u^3 + q - (p/(3u))^3 = 0 multiply by u^3\r\n    // u^6 + qu^3 - (p/3)^3 = 0 quadratic in u^3\r\n    // u^3 = (-q +- sqrt(q^3 + 4(p/3)^3)) / 2 simplified to\r\n    // u^3 = -q/2 +- sqrt((q/2)^2 + (p/3)^3) get v^3 from u^3 - v^3 = -q\r\n    // v^3 = q/2  +- sqrt((q/2)^2 + (p/3)^3)\r\n    // and determine the discriminant:\r\n    const discriminant = roundToDec(q2 * q2 + p3 * p3 * p3, 8);\r\n\r\n    // 1 real root\r\n    if (discriminant > 0) {\r\n        const sqrtDiscriminant = Math.sqrt(discriminant);\r\n        const u = cubeRoot(-q2 + sqrtDiscriminant);\r\n        const v = cubeRoot(q2 + sqrtDiscriminant);\r\n        const x1 = u - v - a3;\r\n        // ignore other imaginary roots\r\n        return [x1];\r\n    }\r\n\r\n    // all roots real (3 in total, 1 single and 1 double)\r\n    if (discriminant === 0) {\r\n        // v = -u\r\n        const u = cubeRoot(-q2);\r\n        // t = u - v, x = t - a/3 = u - v - a/3 = 2u - a/3\r\n        const x1 = 2 * u - a3;\r\n        // conjugate roots produce 1 double root\r\n        const x2 = -u - a3;\r\n        return [x1, x2];\r\n    }\r\n\r\n    // all roots are real and different (unpleasant imaginary discriminant)\r\n    // first represent in polar form (a + bi) = r(cos(phi) + i*sin(phi))\r\n    // factoring out i = sqrt(-1)\r\n    // u^3 = -q/2 + i*sqrt(-discriminant)\r\n    // v^3 = q/2  + i*sqrt(-discriminant)\r\n    // for u^3, a = -q/2, b = sqrt(-discriminant)\r\n    // r^2 = a^2 + b^2 = (-q/2)^2 - discriminant\r\n    // r^2 = (q/2)^2 - ((q/2)^2 + (p/3)^3) = -(p/3)^3\r\n    const r = Math.sqrt(-p3 * p3 * p3);\r\n    // cos(phi) = a/r (triangle with a along Re, b along Im and r hypotenuse)\r\n    let cosphi = -q2 / r;\r\n    // correct for float rounding\r\n    if (cosphi < -1) {\r\n        cosphi = -1;\r\n    } else if (cosphi > 1) {\r\n        cosphi = 1;\r\n    }\r\n    const phi = Math.acos(cosphi);\r\n    // de Moivre's law -> [r(cos(phi) + i*sin(phi)]^n = r^n * (cos(phi/n) + i*sin(phi/n))\r\n    // values below easy to see if seen as vectors in complex plane\r\n    // u = r^(1/3) * (cos(phi/3)  + i*sin(phi/3))\r\n    // v = r^(1/3) * (-cos(phi/3) + i*sin(phi/3))\r\n    // x = u - v - a/3\r\n    // imaginary parts cancel out\r\n    const commonPrefix = 2 * cubeRoot(r);\r\n    const x1 = commonPrefix * Math.cos(phi / 3) - a3;\r\n    const x2 = commonPrefix * Math.cos((phi + 2 * Math.PI) / 3) - a3;\r\n    const x3 = commonPrefix * Math.cos((phi + 4 * Math.PI) / 3) - a3;\r\n    return [x1, x2, x3];\r\n}\r\n\r\nfunction interpolateCubic(p1, cp1, cp2, p2, p) {\r\n    // and rewrite from [a(1-t)^3 + 3bt(1-t)^2 + 3c(1-t)t^2 + dt^3] form\r\n    p1 -= p;\r\n    cp1 -= p;\r\n    cp2 -= p;\r\n    p2 -= p;\r\n\r\n    // to [t^3 + at^2 + bt + c] form:\r\n    const d = -p1 + 3 * cp1 - 3 * cp2 + p2;\r\n    const a = (3 * p1 - 6 * cp1 + 3 * cp2 ) / d;\r\n    const b = (-3 * p1 + 3 * cp1) / d;\r\n    const c = p1 / d;\r\n\r\n    return solveCubicEquation(a, b, c).map(t => roundToDec(t, 4));\r\n}\r\n\r\n\r\n/**\r\n * Get points along the curve from t = [0,1] that share the fixed dimension as betweenPoint.\r\n * For example, if betweenPoint = {x:10, y:null}, then we are looking for all points with\r\n * x = 10.\r\n * @param p1\r\n * @param p2\r\n * @param betweenPoint Query that has either x or y set to null which is to be determined\r\n * @returns {Array} List of draw points that have a \"t\" property which is how far they are along the curve\r\n */\r\nexport function interpolateCurve(p1, p2, betweenPoint) {\r\n    let knownDim;\r\n    if (betweenPoint.x === null) {\r\n        knownDim = \"y\";\r\n    } else if (betweenPoint.y === null) {\r\n        knownDim = \"x\";\r\n    } else {\r\n        return [];\r\n    }\r\n\r\n    const ts = applyToCurve(p1, p2, {\r\n        linear   : (...cps) => interpolateLinear(...cps.map(cp => cp[knownDim]),\r\n            betweenPoint[knownDim]),\r\n        quadratic: (...cps) => interpolateQuadratic(...cps.map(cp => cp[knownDim]),\r\n            betweenPoint[knownDim]),\r\n        cubic    : (...cps) => interpolateCubic(...cps.map(cp => cp[knownDim]),\r\n            betweenPoint[knownDim]),\r\n    }).filter((t) => {\r\n        // solving cubic equations is not very numerically stable...\r\n        t = roundToDec(t, 3);\r\n        return t >= 0 && t <= 1;\r\n    });\r\n\r\n    return ts.map((t) => {\r\n        const p = getPointOnCurve(t, p1, p2);\r\n        p.t = t;\r\n        return p;\r\n    });\r\n\r\n}\r\n\r\n\r\n/**\r\n * Return the control point for a quadratic curve between two points with\r\n * a simple deflection parameter\r\n * @param p1\r\n * @param p2\r\n * @param t How far along the linear between p1 and p2 the control point should start\r\n * @param deflection Which direction and how far perpendicular to the p1-p2 linear\r\n * the control point should be (the norm of the perpendicular vector)\r\n * @returns {{x: number, y: number}}\r\n */\r\nexport function simpleQuadratic(p1, p2, t = 0.5, deflection = 0) {\r\n    const cp1 = getPointOnLine(t, p1, p2);\r\n    return add(cp1, getPerpendicularVector(diff(p1, p2)), deflection);\r\n}\r\n\r\n\r\n/**\r\n * Increase the degree of a cubic curve (e.g. quadratic to cubic) without changing its shape\r\n * @param p1 Starting point of the curve\r\n * @param p2 Ending point of the curve and holds the other control points\r\n */\r\nexport function elevateDegree(p1, p2) {\r\n    const cps = [p1];\r\n    for (let cp in p2) {\r\n        if (cp.startsWith(\"cp\") && p2.hasOwnProperty(cp)) {\r\n            cps.push(p2[cp]);\r\n        }\r\n    }\r\n    cps.push(extractPoint(p2));\r\n\r\n    const newEndPoint = extractPoint(p2);\r\n    // see https://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-elev.html\r\n    for (let i = 1, newDegree = cps.length; i < newDegree; ++i) {\r\n        const coefficient = i / newDegree;\r\n\r\n        newEndPoint[\"cp\" + i] = makePoint((cpsPrev, cps) => {\r\n            return coefficient * cpsPrev + (1 - coefficient) * cps;\r\n        }, cps[i - 1], cps[i]);\r\n    }\r\n    return newEndPoint;\r\n}\r\n\r\n/**\r\n * Get the cubic cubic control point representation of the curve from start to end.\r\n * If end already has 2 control points return them; if end has only 1 control point (quadratic)\r\n * then return 2 control points that would lead to an equivalent curve; if end has no control\r\n * point (linear) then return 2 control points located identically at the midpoint between\r\n * start and end.\r\n * @param p1\r\n * @param p2\r\n * @returns {[*,*]} cp1 and cp2 of end point\r\n */\r\nexport function getCubicControlPoints(p1, p2) {\r\n    return applyToCurve(p1, p2, {\r\n        linear ()  {\r\n            const newEnd = elevateDegree(p1, elevateDegree(p1, p2));\r\n            return [newEnd.cp1, newEnd.cp2];\r\n        },\r\n        quadratic () {\r\n            const newEnd = elevateDegree(p1, p2);\r\n            return [newEnd.cp1, newEnd.cp2];\r\n        },\r\n        cubic: () => [p2.cp1, p2.cp2]\r\n    });\r\n}\r\n\r\n/**\r\n * Transform start curve into end curve (results in cubic cubic) with the amount\r\n * of transformation determined by t [0,1]. Limited to transforming the end point as the start and\r\n * end curves must have the same starting point\r\n * @param t Amount to transform, [0,1] 0 is no transformation at all and is equal to the start curve;\r\n * 1 is full transformation and is equal to the end curve\r\n * @param p1\r\n * @param initP2\r\n * @param endP2\r\n * @returns Replacement draw point for endP2\r\n */\r\nexport function transformCurve(t, p1, initP2, endP2) {\r\n    if (!initP2) {\r\n        return endP2;\r\n    }\r\n    if (!endP2) {\r\n        return initP2;\r\n    }\r\n    const [initCp1, initCp2] = getCubicControlPoints(p1, initP2);\r\n    const [endCp1, endCp2] = getCubicControlPoints(p1, endP2);\r\n    const newEnd = getPointOnLine(t, initP2, endP2);\r\n    newEnd.cp1 = getPointOnLine(t, initCp1, endCp1);\r\n    newEnd.cp2 = getPointOnLine(t, initCp2, endCp2);\r\n    return newEnd;\r\n}\n\n\n// WEBPACK FOOTER //\n// src/curve.js","/**\r\n * Created by Johnson on 2017-04-02.\r\n */\r\n\r\n/**\r\n * Convert radians to degrees\r\n * @param radian\r\n * @returns {number}\r\n */\r\nexport function deg(radian) {\r\n    return 180 * radian / Math.PI;\r\n}\r\n\r\n/**\r\n * Convert degrees to radians\r\n * @param degree\r\n * @returns {number}\r\n */\r\nexport function rad(degree) {\r\n    return degree * Math.PI / 180;\r\n}\r\n\r\n/**\r\n * Unwrap a radian to its equivalent form between [-PI, PI]\r\n * @param rad\r\n */\r\nexport function unwrapRad(rad) {\r\n    while (rad > Math.PI) {\r\n        rad -= 2 * Math.PI;\r\n    }\r\n    while (rad < -Math.PI) {\r\n        rad += 2 * Math.PI;\r\n    }\r\n    return rad;\r\n}\r\n\r\n/**\r\n * Clamp a number between a minimum and maximum value\r\n * @param {number} num\r\n * @param {number} min\r\n * @param {number} max\r\n * @returns {number} Clamped number\r\n */\r\nexport function clamp(num, min, max) {\r\n    return num < min ? min : num > max ? max : num;\r\n}\r\n\r\n/**\r\n * Round a number to a fixed number of decimals\r\n * @param {number} num Number to round\r\n * @param {number} numDecimals Number of decimals\r\n * @returns {number}\r\n */\r\nexport function roundToDec(num, numDecimals) {\r\n    return parseFloat(num.toFixed(numDecimals));\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/numeric.js","\"use strict\";\r\n\r\nimport {breakPoint, clone,  scale, extractPoint} from \"./point\";\r\nimport {simpleQuadratic} from \"./curve\";\r\n\r\n/**\r\n * Styling option to not show stroke or fill\r\n * @readonly\r\n * @type {string}\r\n */\r\nexport const none = \"rgba(0,0,0,0)\";\r\n\r\n/**\r\n * Draw the path formed by the list of drawpoints\r\n * @param {Context2DTracked} ctx Context2D to render to, if it exists\r\n * @param {Object[]} points Ordered list of draw points, each with x and y\r\n */\r\nexport function drawPoints(ctx, ...points) {\r\n    // given ctx and a list of points, draw points between them based on how many control points\r\n    // are defined for each\r\n    // does not begin a path or fill or stroke (just moves pen between the points)\r\n    if (points.length < 1) {\r\n        return;\r\n    }\r\n    let startPoint = points[0];\r\n    // if null is passed through, just continue from last location\r\n    if (startPoint) {\r\n        if (startPoint === breakPoint) {\r\n            startPoint = points[1];\r\n        }\r\n        if (startPoint && startPoint.hasOwnProperty(\"x\")) {\r\n            ctx.moveTo(startPoint.x, startPoint.y);\r\n        }\r\n    }\r\n    // for every point after\r\n    for (let i = 1, len = points.length; i < len; ++i) {\r\n        let p = points[i];\r\n        // allow calls with nonexistent points so that different drawing modes can be\r\n        // consolidated\r\n        if (!p) {\r\n            // console.log(\"don't have point #\", i);\r\n            continue;\r\n        }\r\n        if (p === breakPoint) {\r\n            ++i;\r\n            if (i < points.length) {\r\n                p = points[i];\r\n                ctx.moveTo(p.x, p.y);\r\n            }\r\n        } else if (p.cp2 && p.cp1) {\r\n            ctx.bezierCurveTo(p.cp1.x, p.cp1.y, p.cp2.x, p.cp2.y, p.x, p.y, p.traceOptions);\r\n        } else if (p.cp1) {\r\n            ctx.quadraticCurveTo(p.cp1.x, p.cp1.y, p.x, p.y, p.traceOptions);\r\n        } else if (p.cp2) {\r\n            ctx.quadraticCurveTo(p.cp2.x, p.cp2.y, p.x, p.y, p.traceOptions);\r\n        } else if (p.hasOwnProperty(\"x\")) {\r\n            ctx.lineTo(p.x, p.y);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get the drawpoints for a circle\r\n * @param {object} center Point at the center of the circle\r\n * @param {number} radius Radius in cm\r\n * @returns {object[]} List of draw points for this circle (could be passed to guiMenuItem)\r\n */\r\nexport function drawCircle(center, radius) {\r\n    const stretch = 0.552284749831 * radius;\r\n    let top = {\r\n        x: center.x,\r\n        y: center.y + radius\r\n    };\r\n    let right = {\r\n        x: center.x + radius,\r\n        y: center.y\r\n    };\r\n    let bot = {\r\n        x: center.x,\r\n        y: center.y - radius\r\n    };\r\n    let left = {\r\n        x: center.x - radius,\r\n        y: center.y\r\n    };\r\n    top.cp1 = {\r\n        x: left.x,\r\n        y: left.y + stretch\r\n    };\r\n    top.cp2 = {\r\n        x: top.x - stretch,\r\n        y: top.y\r\n    };\r\n    right.cp1 = {\r\n        x: top.x + stretch,\r\n        y: top.y\r\n    };\r\n    right.cp2 = {\r\n        x: right.x,\r\n        y: right.y + stretch\r\n    };\r\n    bot.cp1 = {\r\n        x: right.x,\r\n        y: right.y - stretch\r\n    };\r\n    bot.cp2 = {\r\n        x: bot.x + stretch,\r\n        y: bot.y\r\n    };\r\n    left.cp1 = {\r\n        x: bot.x - stretch,\r\n        y: bot.y\r\n    };\r\n    left.cp2 = {\r\n        x: left.x,\r\n        y: left.y - stretch\r\n    };\r\n    // doesn't actually matter in which order you draw them\r\n    return [top, right, bot, left, top];\r\n}\r\n\r\nexport function drawSpecificCurl(left, center, right) {\r\n    const p1 = extractPoint(left);\r\n    const p2 = extractPoint(center);\r\n    const p3 = extractPoint(right);\r\n\r\n    {\r\n        const {t = 0.5, deflection = 0.5} = left;\r\n        p2.cp1 = simpleQuadratic(p1, p2, t, deflection);\r\n    }\r\n    {\r\n        const {t = 0.5, deflection = 0.5} = right;\r\n        p3.cp1 = simpleQuadratic(p1, p2, t, deflection);\r\n    }\r\n    return [p1, p2, p3];\r\n}\r\n\r\n\r\n/**\r\n * Debug the curve going into a drawpoint. Use by wrapping a drawpoint with it when returning\r\n * to guiMenuItem.\r\n * @param {object} pt\r\n * @param {object} options Options for how to show the points\r\n * @returns {*}\r\n */\r\nexport function tracePoint(pt, options) {\r\n    if (!options) {\r\n        options = {radius:1};\r\n    } else if (typeof options === \"number\") {\r\n        // convenience for defining radius of trace point\r\n        options = {radius:options};\r\n    }\r\n    pt.traceOptions = {point:options};\r\n    return pt;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Given a curve defined by (start, end), return a draw point such that (end, returned point) looks identical,\r\n * but travels in the opposite direction.\r\n * @param start\r\n * @param end\r\n * @returns {*}\r\n */\r\nexport function reverseDrawPoint(start, end) {\r\n    if (!start || !end) {\r\n        return start;\r\n    }\r\n    return {\r\n        x  : start.x,\r\n        y  : start.y,\r\n        cp1: clone(end.cp2),\r\n        cp2: clone(end.cp1)\r\n    };\r\n}\r\n\r\n/**\r\n * For a cubic curve point, get a control point on the other side of the point so that the\r\n * curve is smooth.\r\n * @param {point} pt End point of a cubic curve (must have 2nd control point)\r\n * @param {number} scaleBy How much back to extend the continuing control point.\r\n * A value of 1 produces a symmetric curve.\r\n * @returns {{x, y}|{x: number, y: number}|*} Continuing control point\r\n */\r\nexport function getSmoothControlPoint(pt, scaleBy) {\r\n    if (pt.hasOwnProperty(\"cp2\") === false) {\r\n        throw new Error(\"point has no second control point; can't get smooth control point\");\r\n    }\r\n    return scale(pt.cp2, -scaleBy, pt);\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// src/draw.js","/**\r\n * Created by johnson on 10.05.17.\r\n */\r\n\r\nexport function clone(obj) {\r\n    if (obj) {\r\n        return JSON.parse(JSON.stringify(obj));\r\n    } else {\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Define a draw point if it doesn't exist already\r\n * @param {object} ex Export holding draw points\r\n * @param {string} drawPointName Name of the location\r\n * @param {object} definition Object holding x, y, cp1, and cp2\r\n */\r\nexport function fillerDefinition(ex, drawPointName, definition = {}) {\r\n    if (ex.hasOwnProperty(drawPointName)) {\r\n        return;\r\n    }\r\n    ex[drawPointName] = definition;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// src/util.js","export * from './util';\r\nexport * from './numeric';\r\nexport * from './point';\r\nexport * from './curve';\r\nexport * from './draw';\r\n\n\n\n// WEBPACK FOOTER //\n// src/index.js"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AACA;;;;AACA;AAcA;AAoCA;AAYA;AAWA;AASA;AAYA;AAUA;AAUA;AAQA;AAOA;AA8BA;AAsBA;AAcA;AAuBA;AACA;;;AA3NA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AADA;AACA;AAGA;;;;;;;AAOA;AACA;AADA;AACA;AAGA;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAAA;AACA;AAFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClPA;AAqBA;AAoBA;AAsGA;AAiKA;AA0CA;AAWA;AA+BA;AAyBA;AACA;AAjaA;AACA;AAAA;AACA;AANA;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAPA;AASA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AALA;AAUA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAYA;AACA;AACA;AACA;AACA;AAhBA;AACA;AAUA;AAAA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AATA;AAWA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxaA;AASA;AAQA;AAiBA;AAUA;AArDA;;;;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;ACvDA;AACA;;;;;AAgBA;AAkDA;AAsDA;AAwBA;AAoBA;AAoBA;AACA;AAxLA;AACA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1LA;AAcA;AAlBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;A","sourceRoot":""}